# ============================================================
#  CI/CD Pipeline â€” Python Backend API (FastAPI / Django / Flask)
#  Plateforme : GitHub Actions
#  Auteur     : GÃ©nÃ©rÃ© par Claude
# ============================================================
#
#  STRUCTURE DU PIPELINE :
#  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
#  â”‚  Lint   â”‚â”€â”€â–¶â”‚  Test    â”‚â”€â”€â–¶â”‚  Build   â”‚â”€â”€â–¶â”‚ Staging  â”‚â”€â”€â–¶â”‚   Prod   â”‚
#  â”‚  & Formatâ”‚   â”‚  & Cover â”‚   â”‚  Docker  â”‚   â”‚  Deploy  â”‚   â”‚  Deploy  â”‚
#  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#
#  DÃ‰CLENCHEURS :
#    - Push sur 'main'    â†’ CI complet + dÃ©ploiement Staging
#    - Push sur 'develop' â†’ CI complet uniquement
#    - Pull Request       â†’ CI complet (lint + tests)
#    - Tag 'v*.*.*'       â†’ CI complet + dÃ©ploiement Production
#
# ============================================================

name: ğŸ Python API â€” CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
    tags:
      - "v*.*.*"
  pull_request:
    branches:
      - main
      - develop

# Annule les runs prÃ©cÃ©dents sur la mÃªme branche pour Ã©conomiser les minutes
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Variables globales partagÃ©es entre les jobs
env:
  PYTHON_VERSION: "3.12"
  IMAGE_NAME: ${{ github.repository }}          # ex: mon-org/mon-api
  REGISTRY: ghcr.io                             # GitHub Container Registry (gratuit)

# ============================================================
# JOB 1 â€” LINT & FORMAT
# VÃ©rifie la qualitÃ© et le style du code avant de lancer les tests
# ============================================================
jobs:
  lint:
    name: ğŸ” Lint & Format
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      - name: ğŸ Installer Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: "pip"                          # Cache pip automatique

      - name: ğŸ“¦ Installer les outils de qualitÃ©
        run: |
          pip install --upgrade pip
          pip install ruff mypy

      - name: âœ¨ VÃ©rifier le formatage (Ruff format)
        run: ruff format --check --diff .

      - name: ğŸ” Linting (Ruff)
        run: ruff check .

      - name: ğŸ·ï¸ VÃ©rification des types (Mypy)
        # Mypy est optionnel â€” retire cette Ã©tape si tu n'utilises pas les type hints
        run: mypy . --ignore-missing-imports
        continue-on-error: true               # Ne bloque pas le pipeline si mypy Ã©choue

# ============================================================
# JOB 2 â€” TESTS & COUVERTURE
# Lance les tests sur plusieurs versions Python en parallÃ¨le
# ============================================================
  test:
    name: ğŸ§ª Tests (Python ${{ matrix.python-version }})
    runs-on: ubuntu-latest
    needs: lint                                # Attend que le lint rÃ©ussisse

    # Test matriciel sur plusieurs versions Python
    strategy:
      fail-fast: false                         # Continue mÃªme si une version Ã©choue
      matrix:
        python-version: ["3.11", "3.12"]

    # Services Docker annexes (base de donnÃ©es, cacheâ€¦)
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      # Variables d'environnement pour les tests
      DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb
      REDIS_URL: redis://localhost:6379
      ENVIRONMENT: test
      SECRET_KEY: test-secret-key-not-used-in-prod

    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      - name: ğŸ Installer Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: "pip"

      - name: ğŸ“¦ Installer les dÃ©pendances
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt   # dÃ©pendances de test (pytest, etc.)

      - name: ğŸ—ƒï¸ Appliquer les migrations
        # Pour Django : python manage.py migrate
        # Pour Alembic (FastAPI/SQLAlchemy) :
        run: |
          # DÃ©commente la ligne correspondant Ã  ton framework :
          # python manage.py migrate                          # Django
          # alembic upgrade head                             # FastAPI + Alembic
          echo "âš ï¸  Configure ici ta commande de migration"

      - name: ğŸ§ª Lancer les tests avec couverture
        run: |
          pytest \
            --cov=app \
            --cov-report=xml \
            --cov-report=term-missing \
            --cov-fail-under=80 \              # Bloque si couverture < 80%
            -v \
            --tb=short \
            tests/

      - name: ğŸ“Š Uploader le rapport de couverture (Codecov)
        uses: codecov/codecov-action@v4
        if: matrix.python-version == env.PYTHON_VERSION   # Upload une seule fois
        with:
          file: ./coverage.xml
          token: ${{ secrets.CODECOV_TOKEN }}  # Optionnel pour repos publics
          fail_ci_if_error: false

# ============================================================
# JOB 3 â€” SCAN DE SÃ‰CURITÃ‰
# DÃ©tecte les vulnÃ©rabilitÃ©s dans les dÃ©pendances et le code
# ============================================================
  security:
    name: ğŸ”’ Scan de sÃ©curitÃ©
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      - name: ğŸ Installer Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: "pip"

      - name: ğŸ“¦ Installer les dÃ©pendances
        run: pip install -r requirements.txt

      - name: ğŸ›¡ï¸ Scanner les vulnÃ©rabilitÃ©s (pip-audit)
        run: |
          pip install pip-audit
          pip-audit --requirement requirements.txt

      - name: ğŸ” Analyse statique de sÃ©curitÃ© (Bandit)
        run: |
          pip install bandit[toml]
          bandit -r app/ -c pyproject.toml
        continue-on-error: true               # Warning, pas bloquant

      - name: ğŸ³ Scanner l'image Docker (Trivy)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          severity: "CRITICAL,HIGH"
          exit-code: "0"                      # Mettre "1" pour bloquer sur vulnÃ©rabilitÃ©s

# ============================================================
# JOB 4 â€” BUILD DOCKER
# Construit et publie l'image sur GitHub Container Registry
# ============================================================
  build:
    name: ğŸ³ Build & Push Docker
    runs-on: ubuntu-latest
    needs: [test, security]                   # Attend tests ET sÃ©curitÃ©
    # Ne build que sur main ou un tag de release (pas sur les PR)
    if: github.event_name != 'pull_request'

    permissions:
      contents: read
      packages: write                         # NÃ©cessaire pour pousser sur ghcr.io

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configurer Docker Buildx (builds multi-plateforme)
        uses: docker/setup-buildx-action@v3

      - name: ğŸ” Se connecter Ã  GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} # Token automatique, pas de config!

      - name: ğŸ·ï¸ GÃ©nÃ©rer les tags et labels Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            # Tag sur le SHA du commit (toujours)
            type=sha,prefix=sha-
            # Tag 'latest' uniquement sur main
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            # Tag sÃ©mantique pour les releases (v1.2.3)
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: ğŸ”¨ Build et push de l'image Docker
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha                # Cache GitHub Actions (rapide)
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64  # Multi-arch (compatible Apple Silicon)
          build-args: |
            BUILD_DATE=${{ github.run_id }}
            GIT_COMMIT=${{ github.sha }}

# ============================================================
# JOB 5 â€” DÃ‰PLOIEMENT STAGING
# DÃ©ploie automatiquement sur l'environnement de staging
# ============================================================
  deploy-staging:
    name: ğŸš€ Deploy â†’ Staging
    runs-on: ubuntu-latest
    needs: build
    # Staging = uniquement sur main (pas sur les tags de release)
    if: github.ref == 'refs/heads/main'

    environment:
      name: staging
      url: https://staging.ton-api.com        # â† Remplace par ton URL staging

    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      # â”€â”€ Option A : DÃ©ploiement SSH vers un VPS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸ–¥ï¸ DÃ©ployer sur VPS via SSH
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /opt/mon-api
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            docker compose -f docker-compose.staging.yml up -d --no-deps api
            docker system prune -f

      # â”€â”€ Option B : DÃ©ploiement Kubernetes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # - name: â˜¸ï¸ DÃ©ployer sur Kubernetes
      #   uses: azure/k8s-deploy@v4
      #   with:
      #     namespace: staging
      #     images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ github.sha }}
      #     manifests: k8s/staging/

      # â”€â”€ Option C : AWS ECS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # - name: â˜ï¸ DÃ©ployer sur AWS ECS
      #   uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      #   with:
      #     task-definition: .aws/task-definition-staging.json
      #     service: mon-api-staging
      #     cluster: mon-cluster

      - name: âœ… Smoke test Staging
        run: |
          sleep 15   # Attendre que le service dÃ©marre
          curl --fail --retry 3 --retry-delay 5 \
            https://staging.ton-api.com/health

      - name: ğŸ“£ Notifier Slack (succÃ¨s)
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "âœ… *Staging dÃ©ployÃ©* â€” `${{ github.ref_name }}` par ${{ github.actor }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: ğŸš¨ Notifier Slack (Ã©chec)
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "âŒ *Staging FAILED* â€” `${{ github.ref_name }}` â€” <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|Voir les logs>"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

# ============================================================
# JOB 6 â€” DÃ‰PLOIEMENT PRODUCTION
# DÃ©ploie en production uniquement sur un tag v*.*.*
# avec approbation manuelle obligatoire
# ============================================================
  deploy-production:
    name: ğŸŒ Deploy â†’ Production
    runs-on: ubuntu-latest
    needs: build
    # Production = uniquement sur les tags de release (ex: v1.2.3)
    if: startsWith(github.ref, 'refs/tags/v')

    environment:
      name: production                        # Configure les reviewers dans GitHub Settings
      url: https://api.ton-domaine.com        # â† Remplace par ton URL production

    steps:
      - name: ğŸ“¥ Checkout du code
        uses: actions/checkout@v4

      # â”€â”€ Option A : DÃ©ploiement SSH avec rollback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸŒ DÃ©ployer en production via SSH
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          script: |
            cd /opt/mon-api
            # Sauvegarder l'image actuelle pour rollback
            CURRENT_TAG=$(docker inspect --format='{{index .RepoTags 0}}' mon-api-prod 2>/dev/null || echo "none")
            echo "Image prÃ©cÃ©dente : $CURRENT_TAG"

            # DÃ©ployer la nouvelle version
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
            docker compose -f docker-compose.prod.yml up -d --no-deps api

            # Smoke test â€” rollback automatique si Ã©chec
            sleep 20
            if ! curl --fail --silent https://api.ton-domaine.com/health; then
              echo "ğŸš¨ Smoke test Ã©chouÃ©, rollback en cours..."
              docker compose -f docker-compose.prod.yml stop api
              docker tag $CURRENT_TAG ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
              docker compose -f docker-compose.prod.yml up -d --no-deps api
              exit 1
            fi
            echo "âœ… Production dÃ©ployÃ©e avec succÃ¨s!"

      - name: âœ… Smoke test Production
        run: |
          curl --fail --retry 5 --retry-delay 10 \
            https://api.ton-domaine.com/health

      - name: ğŸ·ï¸ CrÃ©er une GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          generate_release_notes: true        # GÃ©nÃ¨re les notes depuis les commits
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“£ Notifier l'Ã©quipe (production dÃ©ployÃ©e)
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "ğŸš€ *Production dÃ©ployÃ©e* â€” Version `${{ github.ref_name }}` par ${{ github.actor }}\n<${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ github.ref_name }}|Voir la Release>"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

# ============================================================
# FIN DU PIPELINE
# ============================================================
#
#  SECRETS Ã€ CONFIGURER dans GitHub â†’ Settings â†’ Secrets :
#  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
#  â”‚ Secret                  â”‚ Description                              â”‚
#  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
#  â”‚ STAGING_HOST            â”‚ IP ou domaine du serveur staging         â”‚
#  â”‚ STAGING_USER            â”‚ Utilisateur SSH staging                  â”‚
#  â”‚ STAGING_SSH_KEY         â”‚ ClÃ© privÃ©e SSH staging                   â”‚
#  â”‚ PROD_HOST               â”‚ IP ou domaine du serveur production      â”‚
#  â”‚ PROD_USER               â”‚ Utilisateur SSH production               â”‚
#  â”‚ PROD_SSH_KEY            â”‚ ClÃ© privÃ©e SSH production                â”‚
#  â”‚ SLACK_WEBHOOK_URL       â”‚ Webhook Slack pour les notifications     â”‚
#  â”‚ CODECOV_TOKEN           â”‚ Token Codecov (optionnel, repos publics) â”‚
#  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#
#  FICHIERS Ã€ CRÃ‰ER DANS TON PROJET :
#  â”œâ”€â”€ .github/
#  â”‚   â””â”€â”€ workflows/
#  â”‚       â””â”€â”€ ci-cd.yml                â† CE FICHIER
#  â”œâ”€â”€ Dockerfile                       â† Image Docker de ton API
#  â”œâ”€â”€ docker-compose.staging.yml       â† Config staging
#  â”œâ”€â”€ docker-compose.prod.yml          â† Config production
#  â”œâ”€â”€ requirements.txt                 â† DÃ©pendances de prod
#  â”œâ”€â”€ requirements-dev.txt             â† pytest, coverage, etc.
#  â””â”€â”€ pyproject.toml                   â† Config ruff/black/mypy
#
# ============================================================
